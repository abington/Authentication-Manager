<?php

namespace chippyash\Test\Authentication\Manager\Digest;

use Chippyash\Authentication\Manager\Digest\BasicDigestCollection;
use Chippyash\Authentication\Manager\Encoder\BasicEncoder;
use Chippyash\Type\String\StringType;
use Chippyash\Type\Number\IntType;
use org\bovigo\vfs\vfsStream;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2014-12-19 at 08:31:17.
 */
class BasicDigestCollectionTest extends \PHPUnit_Framework_TestCase
{

    /**
     * @var BasicDigestCollection
     */
    protected $object;
    
    /**
     * Mock
     * @var BasicEncode
     */
    protected $encoder;
    
    /**
     * Mock digest file
     * @var vfsStreamFile
     */
    protected $file;
    
    /**
     * Test realm name
     * @var StringType
     */
    protected $realm;
    
    /**
     * Set up the collection
     * This is more of a component test as it uses a real encoder
     */
    protected function setUp()
    {
        $this->realm = new StringType('realm');
        
        $root = vfsStream::setup();
        $this->file = vfsStream::newFile('digest.txt')
                ->at($root)
                ->setContent('');
        
        $this->encoder = new BasicEncoder();
        $this->encoder->setRealm($this->realm);
        
        $this->object = new BasicDigestCollection(
                $this->encoder, 
                new StringType($this->file->url()));
    }

    public function testCanReadADigestFile()
    {
        $this->setTestData([['foo','realm','bar'],['bob','not-realm','bar']]);
        $ret = $this->object->read();
        $this->assertTrue($ret());
        $this->assertEquals(2,$this->object->count());
    }

    public function testTryingToReadANonExistentDigestFileReturnsFalse()
    {
        unlink($this->file->url());
        $ret = $this->object->read();
        $this->assertFalse($ret());
    }

    public function testCanWriteADigestFile()
    {
        $this->object->add(new StringType('bob'), new StringType('not-realm'));
        //cannot us LOCK_EX on vfs stream, so switched off prior to write
        $ret = $this->object->setWriteOptions(new IntType(0))->write();
        $this->assertTrue($ret());
        $fileContents = file_get_contents($this->file->url());
        $this->assertEquals("bob:realm:2cc0e062ea02014584ef562004b4ee6b\n", $fileContents);
    }

    public function testCanGetDigestEntryIfItExists()
    {
        $this->object->add(new StringType('foo'), new StringType('bar'));
        $ret = $this->object->get(new IntType(0));
        $this->assertInternalType('array', $ret);
        $this->assertEquals(3, count($ret));
        $this->assertEquals('foo', $ret[0]);
        $this->assertEquals('realm', $ret[1]);
        $this->assertEquals('73c82e1ae2eea297725ceca8b96ddb3a', $ret[2]);
    }

    /**
     * @expectedException Chippyash\Authentication\Manager\Exceptions\AuthManagerException
     * @expectedExceptionMessage No digest at index 100
     */
    public function testGetDigestEntryWillThrowExceptionIfNotExists()
    {
        $this->object->get(new IntType(100));
    }

    public function testCanAddADigestEntryIfRealmHasBeenSetOnEncoder()
    {
        $ret = $this->object
                ->add(new StringType('foo'), new StringType('bar'));
        $this->assertTrue($ret());
        $expected = ["foo", "realm", "73c82e1ae2eea297725ceca8b96ddb3a"];
        $this->assertEquals($expected, $this->object->get(new IntType(0)));
    }

    public function testCannotAddADigestEntryIfRealmHasNotBeenSetOnEncoder()
    {
        $sut = new BasicDigestCollection(
                new BasicEncoder(), 
                new StringType($this->file->url()));
        $ret = $sut->add(new StringType('foo'), new StringType('bar'));
        $this->assertFalse($ret());
    }

    public function testCanRetrieveDigestItemAsString()
    {
        $this->object->add(new StringType('foo'), new StringType('bar'));
        $expected = "foo:realm:73c82e1ae2eea297725ceca8b96ddb3a";
        $this->assertEquals($expected, $this->object->asString(new IntType(0)));
    }

    /**
     * @expectedException Chippyash\Authentication\Manager\Exceptions\AuthManagerException
     * @expectedExceptionMessage Digest entry (0) does not exist
     */
    public function testRetrieveAsStringWillThrowExceptionIfEntryDoesNotExist()
    {
        $this->object->asString(new IntType(0));
    }
    public function testCanFindByUidIfRealmIsSet()
    {
        $realm = new StringType('realm');
        $this->object->setRealm($realm);
        $this->setTestData(
            [['foo','realm','bar'],
             ['bar','not-realm','bar'],
             ['bar','realm','password']
            ]);
        $this->object->read();
        $ret = $this->object->findByUid(new StringType('bar'));
        $this->assertEquals(2, $ret());
    }

    /**
     * @expectedException Chippyash\Authentication\Manager\Exceptions\AuthManagerException
     * @expectedExceptionMessage No Realm set
     */
    public function testCannotFindByUidIfRealmIsNotSetAndWillThrowException()
    {
        $this->setTestData(
            [['foo','realm','bar'],
             ['bar','not-realm','bar'],
             ['bar','realm','password']
            ]);
        $this->object->read();
        $this->object->findByUid(new StringType('bar'));
    }

    public function testCanFindByUidWillReturnFalseIfNotFound()
    {
        $realm = new StringType('realm');
        $this->object->setRealm($realm);
        $this->setTestData(
            [['foo','realm','bar'],
             ['bar','not-realm','bar'],
             ['bar','realm','password']
            ]);
        $this->object->read();
        $ret = $this->object->findByUid(new StringType('boo'));
        $this->assertFalse($ret());
    }
    
    public function testCanDeleteIfEntryExists()
    {
        $realm = new StringType('realm');
        $this->object->setRealm($realm);
        $this->setTestData(
            [['foo','realm','bar'],
             ['bar','not-realm','bar'],
             ['bar','realm','password']
            ]);
        $this->object->read();
        $ret = $this->object->findByUid(new StringType('bar'));
        $this->assertTrue($this->object->del($ret)->get());
    }
    
    public function testDeleteWillReturnFalseIfEntryDoesNotExist()
    {
        $realm = new StringType('realm');
        $this->object->setRealm($realm);
        $this->setTestData(
            [['foo','realm','bar'],
             ['bar','not-realm','bar'],
             ['bar','realm','password']
            ]);
        $this->assertFalse($this->object->del(new IntType(100))->get());
    }
    
    protected function setTestData(array $identities)
    {
        $content = '';
        foreach ($identities as $identity) {
            $line = "{$identity[0]}:{$identity[1]}:"
                . md5("{$identity[0]}:{$identity[1]}:{$identity[2]}")
                . PHP_EOL;
            $content .= $line;
        }
        file_put_contents($this->file->url(), $content);
    }
}
